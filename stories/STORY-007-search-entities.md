# STORY-007 Â· Search & Entity Insights Backed by Data Stores

## Overview
Implement the persisted data access for search and entity insights so analysts can explore results generated by the NLP pipeline instead of static mock data.

## Acceptance Criteria
- Backend search route queries Elasticsearch (for text) and PostgreSQL (for structured filters) returning paginated ticket results with sentiment + entity context.
- Entity API (new route) aggregates top entities by count and label for the selected date range.
- Frontend `EntitiesPanel` fetches live data and allows filter input to refine results.
- Tests cover search filtering, empty results, and entity aggregation accuracy.

## Backend Mockup
```python
# backend/services/search_client.py
from elasticsearch import Elasticsearch

es = Elasticsearch(settings.elasticsearch_url)

def search_tickets(query: str, sentiment: str | None, start: datetime | None, end: datetime | None, size: int, offset: int):
    must = []
    if query:
        must.append({"multi_match": {"query": query, "fields": ["summary", "description", "nlp.text"]}})
    if sentiment:
        must.append({"term": {"sentiment": sentiment}})
    if start or end:
        range_filter = {"range": {"created_at": {}}}
        if start:
            range_filter["range"]["created_at"]["gte"] = start.isoformat()
        if end:
            range_filter["range"]["created_at"]["lte"] = end.isoformat()
        must.append(range_filter)

    response = es.search(
        index="tickets",
        from_=offset,
        size=size,
        query={"bool": {"must": must}},
    )
    return response
```

```python
# backend/api/search_api.py
@router.get("/search")
def search_tickets_api(
    q: str | None = None,
    sentiment: str | None = Query(None, regex="^(positive|negative|neutral)$"),
    start_date: str | None = None,
    end_date: str | None = None,
    limit: int = Query(20, le=100),
    offset: int = Query(0, ge=0),
):
    start = parse_iso_date(start_date)
    end = parse_iso_date(end_date)
    results = search_client.search_tickets(q, sentiment, start, end, size=limit, offset=offset)
    hits = [
        {
            "id": hit["_source"]["ticket_id"],
            "summary": hit["_source"]["summary"],
            "sentiment": hit["_source"]["sentiment"],
            "confidence": hit["_source"]["confidence"],
            "created_at": hit["_source"]["created_at"],
            "entities": hit["_source"].get("entities", []),
        }
        for hit in results["hits"]["hits"]
    ]
    return {
        "total": results["hits"]["total"]["value"],
        "results": hits,
        "offset": offset,
        "limit": limit,
    }
```

```python
# backend/api/entities_api.py
@router.get("/entities/top")
def get_top_entities(
    start_date: str | None = None,
    end_date: str | None = None,
    limit: int = Query(20, le=100),
    db: Session = Depends(get_db),
):
    start = parse_iso_date(start_date)
    end = parse_iso_date(end_date)

    query = (
        db.query(Entity.label, Entity.text, func.count(Entity.id).label("count"))
        .join(SentimentResult, SentimentResult.ticket_id == Entity.ticket_id)
        .filter(SentimentResult.created_at.between(start, end + timedelta(days=1)))
        .group_by(Entity.label, Entity.text)
        .order_by(func.count(Entity.id).desc())
        .limit(limit)
    )
    return [
        {"label": label, "text": text, "count": count}
        for label, text, count in query
    ]
```

## Frontend Mockup
```jsx
// client/src/components/EntitiesPanel/EntitiesPanel.js
useEffect(() => {
  const controller = new AbortController();
  const params = new URLSearchParams();
  if (dateRange.start) params.append('start_date', formatISO(dateRange.start));
  if (dateRange.end) params.append('end_date', formatISO(dateRange.end));
  if (searchQuery) params.append('q', searchQuery);

  fetch(`/api/entities/top?${params.toString()}`, { signal: controller.signal })
    .then(res => res.json())
    .then(setEntities)
    .catch(err => {
      if (err.name !== 'AbortError') enqueueSnackbar('Failed to fetch entities', { variant: 'error' });
    });

  return () => controller.abort();
}, [searchQuery, dateRange]);
```

```jsx
// client/src/components/Search/SearchPanel.js (new)
const [results, setResults] = useState([]);

const handleSearch = async () => {
  const params = new URLSearchParams({ q, sentiment, start_date, end_date, limit: '20', offset: String(page * 20) });
  const res = await fetch(`/api/search?${params}`);
  const data = await res.json();
  setResults(data.results);
};
```

## Additional Notes
- Ensure Elasticsearch indexing happens inside ingestion pipeline (e.g., `search_client.index_ticket(ticket_payload)` after each record).
- Provide fallback path if Elasticsearch disabled (pure PostgreSQL search using `ILIKE`).
- Update Docker compose to include Elasticsearch service for local dev.

